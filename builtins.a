;	Builtin operations for mudlle compiler

	SECTION text

	XDEF	_bbadargs
	XDEF	_bsubtract
	XDEF	_bcompare
	XDEF	_bor
	XDEF	_band
	XDEF	_bleq
	XDEF	_blne
	XDEF	_bllt
	XDEF	_blle
	XDEF	_blgt
	XDEF	_blge
	XDEF	_bbitor
	XDEF	_bbitxor
	XDEF	_bbitand
	XDEF	_bshift_left
	XDEF	_bshift_right
	XDEF	_badd
	XDEF	_bmultiply
	XDEF	_bdivide
	XDEF	_bremainder
	XDEF	_bnegate
	XDEF	_bnot
	XDEF	_bbitnot
	XDEF	_bref
	XDEF	_bcons
	XDEF	_bcall
	XDEF	_balloc
	XDEF	_balloc_readonly
	XDEF	_bcar
	XDEF	_bcdr
	XDEF	_bwglobal
	XDEF	_berror
	XDEF	_bvarargs
	XDEF	_mc_invoke
	XDEF	_interpreter_invoke

; Constants

type_list	equ	10
object_type	equ	5	; offset of type in object
object_offset	equ	8	; size of object header (w/o GCDEBUG)
function_offset equ	28	; offset of mcode field in struct mcode (after header)
true		equ	3	; mudlle rep of true
false		equ	1	; mudlle rep of false
runtime_error_bad_function equ 0
runtime_error_stack_underflow equ 1
runtime_error_bad_type equ 2
runtime_error_divide_by_zero equ 3
runtime_error_bad_index equ 4
runtime_error_bad_value equ 5
runtime_error_variable_read_only equ 6
runtime_error_loop equ 7
runtime_error_recurse equ 8
runtime_error_wrong_parameters equ 9
runtime_error_security_violation equ 10
runtime_error_value_read_only equ 11
runtime_error_user_interrupt equ 12

	XREF	_dprintf
	XREF	_save_registers
	XREF	_extra_registers
	XREF	_initial_stack
	XREF	_final_stack
	XREF	_runtime_error
	XREF	_environment
	XREF	_startgen0
	XREF	_posgen0
	XREF	_LinkerDB
	XREF	_code_string_append
	XREF	_code_ref
	XREF	_code_cons
	XREF	_minorgen
	XREF	_garbage_collect
	XREF	_interpreter_start
	XREF	_check_registers
	XREF	_mvars
	XREF	_safehaven

; debugging macro

DPRT	MACRO
	movem.l	a0-a1/d0-d1,-(a7)
	move.l	#\1,-(a7)
	jsr	_dprintf
	addq.l	#4,a7
	movem.l	(a7)+,a0-a1/d0-d1
	ENDM

INTVAL	MACRO	; register with mudlle int
	asr.l	#1,\1
	ENDM

MAKEINT	MACRO	; register with int
	add.l	\1,\1
	addq.l	#1,\1
	ENDM

SCCALLGC MACRO
	move.l	a7,_final_stack
	ENDM

CCALLGC MACRO	; C function
	movem.l	a1-a5,_save_registers
	move.l	d7,_posgen0
	movem.l	d1-d5,_extra_registers
	lea	_LinkerDB,a4
;	jsr	_check_registers
	jsr	\1
	move.l	_posgen0,d7
	move.l	_startgen0,d6
	move.l	_environment,a6
	move.l	object_offset+8(a6),a6
	movem.l	_save_registers,a1-a5
	movem.l	_extra_registers,d1-d5
	ENDM

_bwglobal:
	move.l	_mvars,a0
	move.l	(a0,d0),d0
	and.b	#1,d0
	beq.s	readonly
	rts

readonly:
	move.l	#runtime_error_variable_read_only,-(a7)

error	clr.l	d1
	CCALLGC	_runtime_error
	; never returns

_berror:
	ext.l	d0
	move.l	d0,-(a7)
	bra	error

_bbadargs:
	SCCALLGC
	move.l	#runtime_error_wrong_parameters,-(a7)
	bra	error

badtype:
	SCCALLGC
	move.l	#runtime_error_bad_type,-(a7)
	bra	error

divide0:
	SCCALLGC
	move.l	#runtime_error_divide_by_zero,-(a7)
	bra	error

int1arg	move.l	d0,d1
	and.b	#1,d1
	beq	badtype
	rts

int2args:
	move.l	d1,a0
	and.b	#1,d1
	beq	badtype
	move.l	a0,d1
	move.l	d0,a0
	and.b	#1,d0
	beq	badtype
	move.l	a0,d0
	rts
	

; Basic builtin operations get their arguments in d0 (1) and d1 (2)
; and return their result in d0.
; a0 is available as scratch, all other registers must be preserved

; Simple operations with no type checking: or, and, ==, !=, not

_bor:
	or.l	d1,d0
	subq.l	#1,d0
	bne.s	istrue

isfalse moveq	#false,d0
	rts

istrue	moveq	#true,d0
	rts

_band:
	subq.l	#1,d0
	beq.s	isfalse
	subq.l  #1,d1
	beq.s	isfalse
	bra.s	istrue

_bleq:
	cmp.l	d1,d0
	beq.s	istrue
	bra.s	isfalse

_blne:
	cmp.l	d1,d0
	bne.s	istrue
	bra.s	isfalse

_bnot:
	subq.l	#1,d0
	beq.s	istrue
	bra.s	isfalse

; Simple integer operations: <, <=, >, >=, |, &, ^, <<, >>, -, *, /, %, ~, 
; - (unary), + (int)

RELOP	MACRO	; op
_bl\1:
	bsr.s	int2args
	cmp.l	d1,d0
	b\1.s	istrue
	bra.s	isfalse
	ENDM

	RELOP	lt
	RELOP	le
	RELOP	gt
	RELOP	ge

_bbitand:
	bsr.s	int2args
	and.l	d1,d0
	rts

_bbitor:
	bsr.s	int2args
	or.l	d1,d0
	rts

_bbitxor:
	bsr.s	int2args
	eor.l	d1,d0
	addq.b	#1,d0		; set type bit
	rts

_bshift_left:
	bsr.s	int2args
	INTVAL	d1
	subq.b	#1,d0		; clear type bit
	asl.l	d1,d0
	addq.b	#1,d0		; set type bit
	rts

_bshift_right:
	bsr	int2args
	INTVAL	d1		; make real int from mudlle int
	asr.l	d1,d0
	or.b	#1,d0		; set type bit
	rts

_bsubtract:
	bsr	int2args
	subq.l	#1,d1
	sub.l	d1,d0
	rts

_bcompare:
	bsr	int2args
	sub.l	d1,d0
	rts			; must leave condition codes correct for <, <=, ...

_bmultiply:			
	bsr	int2args
	INTVAL	d0
	INTVAL	d1
	muls.l	d1,d0
	MAKEINT d0
	rts

_bdivide:			
	bsr	int2args
	INTVAL	d0
	INTVAL	d1
	beq	divide0
	divs.l	d1,d0
	MAKEINT d0
	rts

_bremainder:
	bsr	int2args
	INTVAL	d0
	INTVAL	d1
	beq	divide0
	divsl.l	d1,d1:d0
	move.l	d1,d0
	MAKEINT d0
	rts

_bnegate:
	bsr	int1arg
	neg.l	d0
	addq.l	#2,d0
	rts

_bbitnot:
	bsr	int1arg
	not.l	d0
	addq.b	#1,d0
	rts

_badd:
	move.l	d0,a0
	and.b	#1,d0
	beq.s	cadd1
	move.l	a0,d0
	move.l	d1,a0
	and.b	#1,d1
	beq.s	cadd2

	add.l	a0,d0
	subq.l	#1,d0
	rts
	
; Call C code: ref, + (string), . (cons)

cadd1	move.l	a0,d0
	bra.s	cadd
cadd2	move.l	a0,d1
cadd	SCCALLGC
	movem.l	d0/d1,-(a7)
	CCALLGC	_code_string_append
	addq.l	#8,a7
	rts

stringref:
	move.l	d1,d0
	and.b	#1,d0
	beq	badtype
	INTVAL	d1
	bmi.s	badindex
	add.l	#object_offset+1,d1
	cmp.l	(a0),d1
	bge.s	badindex
	move.b	-1(a0,d1.l),d0
	extb.l	d0
	MAKEINT	d0
	rts

_bref	move.l	d0,a0
	tst.l	d0
	beq	badtype
	move.b	object_type(a0),d0
	subq.b	#8,d0
	beq.s	stringref
	subq.b	#1,d0
	bne.s	ref
	;vector ref
	move.l	d1,d0
	and.b	#1,d0
	beq	badtype
	asl.l	#1,d1
	bmi.s	badindex
	add.l	#object_offset-2,d1
	cmp.l	(a0),d1
	bge.s	badindex
	move.l	0(a0,d1.l),d0
	rts

badindex:
	SCCALLGC
	move.l	#runtime_error_bad_index,-(a7)
	bra	error

ref	SCCALLGC
	move.l	a0,d0
	movem.l	d0/d1,-(a7)
	CCALLGC	_code_ref	; ref never causes a gc
	addq.l	#8,a7
	rts

	

_bcons	move.l	d0,-(a7)
consresume:
	move.l	d7,a0
	moveq	#object_offset+8,d0
	sub.l	d0,a0
	cmp.l	d6,a0
	bcs.s	consgc
	;success
	move.l	a0,d7
	move.l	d0,(a0)
	move.l	#$010a0000,4(a0)
	move.l	_minorgen,8(a0)
	move.l	d1,object_offset+4(a0)
	move.l	(a7)+,object_offset(a0)
	move.l	a0,d0
	rts

consgc	move.l	(a7)+,_safehaven	; hack of the day (safehaven is staticpro)
	SCCALLGC
	move.l	d0,-(a7)
	CCALLGC	_garbage_collect
	addq.l	#4,a7
	move.l	_safehaven,-(a7)
	bra	consresume

_bcar	tst.l	d0
	beq	badtype
	move.l	d0,a0
	and.b	#1,d0
	bne	badtype
	cmp.b	#type_list,object_type(a0)
	bne	badtype
	move.l	object_offset(a0),d0
	rts

_bcdr	tst.l	d0
	beq	badtype
	move.l	d0,a0
	and.b	#1,d0
	bne	badtype
	cmp.b	#type_list,object_type(a0)
	bne	badtype
	move.l	object_offset+4(a0),d0
	rts

; Special: alloc, call

; d0 is size of allocation (must be multiple of 4)
; a0 is available, all others must be preserved
; d6-d7 are allocation limit and current pos
_balloc:
resume	move.l	d7,a0
	sub.l	d0,a0
	cmp.l	d6,a0
	bcs.s	gc
	; success
	move.l	a0,d7
	move.l	d0,(a0)
	clr.w	6(a0)
	move.l	_minorgen,8(a0)
	rts
gc	SCCALLGC
	move.l	d0,-(a7)
	move.l	d0,-(a7)
	CCALLGC	_garbage_collect
	addq.l	#4,a7
	move.l	(a7)+,d0
	bra.s	resume

_balloc_readonly:
rresume	move.l	d7,a0
	sub.l	d0,a0
	cmp.l	d6,a0
	bcs.s	rgc
	; success
	move.l	a0,d7
	move.l	d0,(a0)
	move.w	#1,6(a0)
	move.l	_minorgen,8(a0)
	rts
rgc	SCCALLGC
	move.l	d0,-(a7)
	move.l	d0,-(a7)
	CCALLGC	_garbage_collect
	addq.l	#4,a7
	move.l	(a7)+,d0
	bra.s	rresume

; d1 contains the closure to be called
; a0 is available, all others must be preserved
; result must end up in d0
_bcall:
	move.l	d1,a0
	and.b	#1,d1
	bne.s	badfunction
	move.l	a0,d1
	beq.s	badfunction
	move.b	object_type(a0),d1
	subq.b	#1,d1
	beq.s	call_closure
	ext.l	d0
	SCCALLGC
	subq.b	#3,d1
	beq.s	call_primitive
	subq.b	#1,d1
	beq	call_varargs
	subq.b	#1,d1
	beq.s	call_secure

badfunction:
	SCCALLGC
	move.l	#runtime_error_bad_function,-(a7)
	bra	error

call_closure:
	move.l	a0,d1
	move.l	object_offset(a0),a0
	jmp	object_offset+function_offset(a0)

call_secure:
call_primitive:
	addq.l	#1,object_offset+8(a0)	; increase call count
	move.l	object_offset+4(a0),a0
	cmp.w	12(a0),d0		; check arg count
	bne	_bbadargs
	move.l	8(a0),a0
	tst.w	d0
	beq	noargs
	subq.w	#1,d0
	beq	onearg
	subq.w	#1,d0
	beq	twoargs
	subq.w	#1,d0
	beq.s	threeargs
	subq.w	#1,d0
	beq.s	fourargs
	subq.w	#1,d0
	beq.s	fiveargs
	bra	_bbadargs

fiveargs:
	move.l	a0,d0
	move.l	d5,a0
	move.l	object_offset+4(a0),d1
	move.l	d1,-(a7)
	move.l	object_offset(a0),d1
	move.l	d1,-(a7)
	move.l	d0,a0
	move.l	d4,-(a7)
	move.l	d3,-(a7)
	move.l	d2,-(a7)
	bsr	ccall
	lea	20(a7),a7
	rts

fourargs:
	move.l	d5,-(a7)
	move.l	d4,-(a7)
	move.l	d3,-(a7)
	move.l	d2,-(a7)
	bsr	ccall
	lea	16(a7),a7
	rts

threeargs:
	move.l	d4,-(a7)
	move.l	d3,-(a7)
	move.l	d2,-(a7)
	bsr	ccall
	lea	12(a7),a7
	rts

twoargs:
	move.l	d3,-(a7)
	move.l	d2,-(a7)
	bsr	ccall
	addq.l	#8,a7
	rts
onearg:
	move.l	d2,-(a7)
	bsr	ccall
	addq.l	#4,a7	
	rts

noargs:
	bsr	ccall
	rts

call_varargs:
	; make a vector of the arguments
	ext.l	d0
	move.l	d0,-(a7)
	asl.l	#2,d0
	add.l	#object_offset,d0
	move.l	a0,d1

vresume	move.l	d7,a0
	sub.l	d0,a0
	cmp.l	d6,a0
	bcs.s	vargc
	; success
	move.l	a0,d7
	move.l	a0,-(a7)
	move.l	d0,(a0)+
	move.w	#$0109,(a0)+
	clr.w	(a0)+
	move.l	_minorgen,(a0)+

	sub.l	#object_offset,d0
	beq.s	vnoargs
	subq.l	#4,d0
	beq.s	vonearg
	subq.l	#4,d0
	beq.s	vtwoargs
	subq.l	#4,d0
	beq.s	vthreeargs
	subq.l	#4,d0
	beq.s	vfourargs

	movem.l	a0/a1,-(a7)
	move.l	d5,a1
	lea	12(a0),a0
	lea	object_offset(a1),a1	; skip header

vcopy	move.l	(a1)+,(a0)+
	subq.l	#4,d0
	bpl.s	vcopy

	movem.l	(a7)+,a0/a1
	bra.s	vthreeargs

vfourargs:
	move.l	d5,12(a0)
vthreeargs:
	move.l	d4,8(a0)
vtwoargs:
	move.l	d3,4(a0)
vonearg:
	move.l	d2,(a0)
vnoargs:
	move.l	d1,a0
	addq.l	#1,object_offset+8(a0)	; increase call count
	move.l	object_offset+4(a0),a0
	move.l	8(a0),a0
	bsr	ccall
	addq.l	#8,a7
	rts

vargc	SCCALLGC
	move.l	d0,-(a7)
	move.l	d0,-(a7)
	CCALLGC	_garbage_collect
	addq.l	#4,a7
	move.l	d0,a0
	move.l	(a7)+,d0
	bra	vresume

ccall	movem.l	a1-a5,_save_registers
	clr.l	_extra_registers
	clr.l	_extra_registers+4
	clr.l	_extra_registers+8
	clr.l	_extra_registers+12
	clr.l	_extra_registers+16
	move.l	d7,_posgen0
	lea	_LinkerDB,a4
;	move.l	a0,a3
;	jsr	_check_registers
	move.l	(a7)+,a2		; save return address
;	jsr	(a3)
	jsr	(a0)
	move.l	_posgen0,d7
	move.l	_startgen0,d6
	move.l	_environment,a6
	move.l	object_offset+8(a6),a6
	move.l	a2,a0
	movem.l	_save_registers,a1-a5
	clr.l	d2
	clr.l	d3
	clr.l	d4
	clr.l	d5
	jmp	(a0)

_bvarargs:
	; make a vector of the arguments
	ext.l	d0
	asl.l	#2,d0
	add.l	#object_offset,d0

v2r	move.l	d7,a0
	sub.l	d0,a0
	cmp.l	d6,a0
	bcs.s	var2gc
	; success
	move.l	a0,d7
	move.l	d0,(a0)+
	move.w	#$0109,(a0)+
	clr.w	(a0)+
	move.l	_minorgen,(a0)+

	sub.l	#object_offset,d0
	beq.s	v2noargs
	subq.l	#4,d0
	beq.s	v2onearg
	subq.l	#4,d0
	beq.s	v2twoargs
	subq.l	#4,d0
	beq.s	v2threeargs
	subq.l	#4,d0
	beq.s	v2fourargs

	movem.l	a0/a1,-(a7)
	move.l	d5,a1
	lea	12(a0),a0
	lea	object_offset(a1),a1	; skip header

v2copy	move.l	(a1)+,(a0)+
	subq.l	#4,d0
	bpl.s	v2copy

	movem.l	(a7)+,a0/a1
	bra.s	v2threeargs

v2fourargs:
	move.l	d5,12(a0)
v2threeargs:
	move.l	d4,8(a0)
v2twoargs:
	move.l	d3,4(a0)
v2onearg:
	move.l	d2,(a0)
v2noargs:
	move.l	a0,d2
	sub.l	#object_offset,d2
	rts

var2gc	SCCALLGC
	move.l	d0,-(a7)
	move.l	d0,-(a7)
	CCALLGC	_garbage_collect
	addq.l	#4,a7
	move.l	d0,a0
	move.l	(a7)+,d0
	bra	v2r

_mc_invoke:
	movem.l	d2-d7/a2-a6,-(a7)
	move.l	a7,_initial_stack
	move.l	_posgen0,d7
	move.l	_startgen0,d6
	move.l	_environment,a6
	move.l	object_offset+8(a6),a6
	move.l	d1,a0
	move.l	object_offset(a0),a0
	sub.l	a1,a1
	sub.l	a2,a2
	sub.l	a3,a3
	sub.l	a4,a4
	sub.l	a5,a5
	jsr	object_offset+function_offset(a0)
	move.l	d7,_posgen0
	movem.l	(a7)+,d2-d7/a2-a6
	rts

_interpreter_invoke:
	move.l	a7,_final_stack
	movem.l	a1-a5,_save_registers
	clr.l	_extra_registers
	clr.l	_extra_registers+4
	clr.l	_extra_registers+8
	clr.l	_extra_registers+12
	clr.l	_extra_registers+16
	move.l	d7,_posgen0
	lea	_LinkerDB,a4
;	movem.l	d0/d1,-(a7)
;	jsr	_check_registers
;	movem.l	(a7)+,d0/d1
	jsr	_interpreter_start
	move.l	_posgen0,d7
	move.l	_startgen0,d6
	move.l	_environment,a6
	move.l	object_offset+8(a6),a6
	movem.l	_save_registers,a1-a5
	clr.l	d2
	clr.l	d3
	clr.l	d4
	clr.l	d5
	rts

	END
